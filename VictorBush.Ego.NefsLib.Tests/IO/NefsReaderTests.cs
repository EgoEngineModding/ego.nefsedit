// See LICENSE.txt for license information.

using System.IO.Abstractions.TestingHelpers;
using System.Runtime.InteropServices;
using VictorBush.Ego.NefsLib.IO;
using VictorBush.Ego.NefsLib.Progress;
using Xunit;

namespace VictorBush.Ego.NefsLib.Tests.IO;

public class NefsReaderTests
{
	private readonly MockFileSystem fileSystem = new();
	private readonly NefsProgress p = new(CancellationToken.None);

	[Fact]
	public async Task ReadHeaderIntroAsync_Dirt2V150Ps3Proto()
	{
		var expectedResult =
			new NefsReader.DecryptHeaderIntroResult(true, IsEncrypted: false, IsXorEncoded: false, IsLittleEndian: false);
		byte[] bytes =
		{
			// 5 bytes offset
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

			// Header intro
			0x53, 0x46, 0x65, 0x4E, 0x00, 0x11, 0x81, 0x10, 0x00, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x23, 0xA0, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
			0x00, 0x03, 0x57, 0x70, 0x00, 0x07, 0x3C, 0xF0, 0x00, 0x09, 0xB8, 0xF4, 0x00, 0x11, 0x81, 0x00,
			0x38, 0x31, 0x38, 0x33, 0x41, 0x45, 0x32, 0x44, 0x33, 0x34, 0x44, 0x33, 0x33, 0x42, 0x44, 0x43,
			0x33, 0x41, 0x43, 0x35, 0x37, 0x36, 0x38, 0x43, 0x31, 0x36, 0x36, 0x39, 0x43, 0x38, 0x34, 0x41,
			0x36, 0x31, 0x31, 0x31, 0x37, 0x35, 0x30, 0x32, 0x42, 0x41, 0x34, 0x42, 0x39, 0x44, 0x33, 0x38,
			0x30, 0x38, 0x38, 0x44, 0x41, 0x42, 0x41, 0x44, 0x38, 0x41, 0x42, 0x32, 0x30, 0x44, 0x35, 0x30,

			// Extra bytes
			0xFF, 0xFF,
		};

		var stream = new MemoryStream(bytes);
		var reader = new NefsReader(this.fileSystem);
		var offset = 5;

		// Test
		using var actualStream = new MemoryStream();
		var actualResult = await reader.ReadHeaderIntroAsync(stream, offset, actualStream, false, this.p);

		// Verify
		var actualBytes = actualStream.ToArray();
		Assert.Equal(expectedResult, actualResult);
		Assert.Equal([], actualBytes);
	}

	[Fact]
	public async Task ReadHeaderIntroAsync_Dirt2V151()
	{
		var expectedResult =
			new NefsReader.DecryptHeaderIntroResult(true, IsEncrypted: true, IsXorEncoded: true, IsLittleEndian: true);
		byte[] bytes =
		{
			// 5 bytes offset
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

			// Header intro
			0x77, 0x65, 0x6C, 0x38, 0x9B, 0xB9, 0x5F, 0x18, 0x1F, 0x3E, 0x1A, 0x8F, 0x28, 0xDC, 0xA5, 0xB0, 0x0B, 0xC8,
			0x71, 0x08, 0xFC, 0xA9, 0x37, 0x41, 0x6D, 0x4E, 0x55, 0xE7, 0xCF, 0xC1, 0x56, 0x05, 0x90, 0xDD, 0x7F, 0xF4,
			0x5E, 0xA2, 0x6B, 0x5D, 0x7B, 0x4C, 0xC2, 0x7D, 0x1A, 0x1B, 0xC4, 0x60, 0xAF, 0x59, 0xE6, 0xC9, 0x87, 0xDC,
			0x65, 0xA1, 0x4D, 0xCF, 0x77, 0xCD, 0x7E, 0x40, 0xB4, 0x2E, 0x1D, 0x0F, 0xBE, 0xED, 0x57, 0x4C, 0xBA, 0x65,
			0x66, 0xCA, 0x74, 0x03, 0xDA, 0x83, 0xF6, 0x0B, 0xA3, 0xAF, 0xC8, 0xF9, 0x1F, 0xB0, 0x7D, 0x60, 0x8B, 0x5B,
			0x56, 0xF3, 0x10, 0x10, 0x8E, 0x8E, 0xD2, 0x2B, 0xF9, 0x27, 0xD7, 0xD0, 0xED, 0x73, 0x49, 0x8A, 0x5E, 0x66,
			0xCB, 0x8F, 0xE7, 0x2B, 0x4B, 0xE7, 0x67, 0xA0, 0x5D, 0x28, 0x1E, 0x28, 0x94, 0x04, 0x80, 0xCD, 0x52, 0xDB,
			0x79, 0x3E,

			// Extra bytes
			0xFF, 0xFF,
		};
		var expectedBytes = new byte[]
		{
			0x4E, 0x65, 0x46, 0x53, 0x00, 0x04, 0x00, 0x00, 0x01, 0x05, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x88, 0x01, 0x00, 0x00,
			0xBC, 0x02, 0x00, 0x00, 0x78, 0x03, 0x00, 0x00, 0xC8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBC, 0x85,
			0xC9, 0xB4, 0x8F, 0x51, 0xE2, 0xF0, 0x38, 0x31, 0x38, 0x33, 0x41, 0x45, 0x32, 0x44, 0x33, 0x34, 0x44, 0x33,
			0x33, 0x42, 0x44, 0x43, 0x33, 0x41, 0x43, 0x35, 0x37, 0x36, 0x38, 0x43, 0x31, 0x36, 0x36, 0x39, 0x43, 0x38,
			0x34, 0x41, 0x36, 0x31, 0x31, 0x31, 0x37, 0x35, 0x30, 0x32, 0x42, 0x41, 0x34, 0x42, 0x39, 0x44, 0x33, 0x38,
			0x30, 0x38, 0x38, 0x44, 0x41, 0x42, 0x41, 0x44, 0x38, 0x41, 0x42, 0x32, 0x30, 0x44, 0x35, 0x30, 0xBC, 0x85,
			0x00, 0x00,
		};

		var stream = new MemoryStream(bytes);
		var reader = new NefsReader(this.fileSystem);
		var offset = 5;

		// Test
		using var actualStream = new MemoryStream();
		var actualResult = await reader.ReadHeaderIntroAsync(stream, offset, actualStream, false, this.p);

		// Verify
		var actualBytes = actualStream.ToArray();
		Assert.Equal(expectedResult, actualResult);
		Assert.Equal(expectedBytes, actualBytes);
	}

	[Fact]
	public async Task ReadHeaderIntroAsync_Dirt3V151X360()
	{
		var expectedResult =
			new NefsReader.DecryptHeaderIntroResult(true, IsEncrypted: false, IsXorEncoded: true, IsLittleEndian: false);
		byte[] bytes =
		{
			// 5 bytes offset
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

			// Header intro
			0x76, 0xB5, 0xEE, 0xC0, 0x0A, 0x65, 0xC5, 0x89, 0x0A, 0x64, 0x5B, 0x39, 0x0A, 0x65, 0x52, 0xC3,
			0x0A, 0x65, 0x5E, 0x38, 0x0A, 0x66, 0x5B, 0x39, 0x25, 0xFB, 0x0C, 0x5E, 0x0A, 0x65, 0x52, 0x43,
			0x25, 0xFB, 0x0C, 0x5E, 0x0A, 0x65, 0x52, 0xC1, 0x0A, 0x67, 0x31, 0x1D, 0x76, 0xBD, 0x9E, 0x20,
			0x25, 0xF3, 0x8B, 0x8E, 0x0A, 0x6D, 0xB4, 0x09, 0x2F, 0x9C, 0x7B, 0x6F, 0x67, 0xB8, 0x13, 0x6F,
			0x64, 0xCC, 0x63, 0x66, 0x61, 0xCD, 0x11, 0x13, 0x66, 0xCB, 0x17, 0x13, 0x17, 0xCF, 0x64, 0x67,
			0x60, 0xC9, 0x63, 0x12, 0x67, 0xCC, 0x19, 0x64, 0x12, 0xC8, 0x63, 0x62, 0x16, 0xC3, 0x63, 0x15,
			0x14, 0xCE, 0x10, 0x61, 0x66, 0xB9, 0x63, 0x60, 0x13, 0xC2, 0x64, 0x60, 0x1C, 0xBB, 0x64, 0x61,
			0x17, 0xC2, 0x15, 0x62, 0x61, 0xBF, 0x14, 0x6E, 0x1D, 0xC2, 0x13, 0x13, 0x4C, 0x31, 0xBB, 0x22,

			// Extra bytes
			0xFF, 0xFF,
		};
		var expectedBytes = new byte[]
		{
			0x53, 0x46, 0x65, 0x4E, 0x00, 0x08, 0x71, 0x80, 0x00, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x0C, 0x7B, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x01, 0x2C, 0x08, 0x00, 0x02, 0x63, 0xDC, 0x00, 0x02, 0xF4, 0x94, 0x00, 0x08, 0x70, 0xE0,
			0x00, 0x08, 0x87, 0xD0, 0x7C, 0xD0, 0x2A, 0x29, 0x25, 0xFA, 0x20, 0x56, 0x42, 0x42, 0x33, 0x39,
			0x41, 0x36, 0x43, 0x30, 0x44, 0x37, 0x31, 0x45, 0x43, 0x31, 0x37, 0x45, 0x32, 0x35, 0x44, 0x31,
			0x45, 0x33, 0x43, 0x44, 0x42, 0x36, 0x39, 0x32, 0x37, 0x32, 0x43, 0x34, 0x33, 0x39, 0x43, 0x43,
			0x31, 0x34, 0x30, 0x37, 0x43, 0x43, 0x43, 0x36, 0x36, 0x38, 0x44, 0x36, 0x39, 0x41, 0x44, 0x37,
			0x32, 0x38, 0x35, 0x34, 0x44, 0x45, 0x34, 0x38, 0x38, 0x38, 0x33, 0x45, 0x4C, 0x31, 0xBB, 0x22,
		};

		var stream = new MemoryStream(bytes);
		var reader = new NefsReader(this.fileSystem);
		var offset = 5;

		// Test
		using var actualStream = new MemoryStream();
		var actualResult = await reader.ReadHeaderIntroAsync(stream, offset, actualStream, false, this.p);

		// Verify
		var actualBytes = actualStream.ToArray();
		Assert.Equal(expectedResult, actualResult);
		Assert.Equal(expectedBytes, actualBytes);
	}

	[Fact]
	public async Task DecodeXorIntro()
	{
		var inputBuffer = new byte[]
		{
			0xEC, 0xFF, 0xFF, 0xFF, 0x0B, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xEB, 0xFF, 0xFF, 0xFF, 0xE8, 0xFF,
			0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
			0x08, 0x00, 0x00, 0x00, 0xE1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xEA, 0xFF,
			0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00,
			0x1C, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x18, 0x00,
			0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
			0x15, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xFF, 0xFF,
			0xFF, 0xFF
		};
		var inputStream = new MemoryStream(inputBuffer);
		var expected = Enumerable.Range(-32, 32).ToArray();
		var expectedBuffer = MemoryMarshal.Cast<int, byte>(expected).ToArray();

		// Act
		var actualBuffer = await NefsReader.DecodeXorIntroAsync(inputStream, 0, CancellationToken.None);

		// Assert
		Assert.Equal(expectedBuffer, actualBuffer);
	}
}
